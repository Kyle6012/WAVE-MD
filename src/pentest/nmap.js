const net = require('net');
const tls = require('tls');

async function identifyProtocol(target, port) {
    return new Promise((resolve) => {
        const client = new net.Socket();
        let protocol = 'Unknown';

        client.setTimeout(5000);
        client.connect(port, target, () => {
            // Send HTTP request as initial probe
            client.write('HEAD / HTTP/1.1\r\nHost: ' + target + '\r\n\r\n');
        });

        client.on('data', (data) => {
            const response = data.toString();

            if (response.includes('SSH')) {
                protocol = 'SSH';
            } else if (response.includes('HTTP') || response.includes('html')) {
                protocol = 'HTTP';
            } else if (response.includes('220') && response.includes('FTP')) {
                protocol = 'FTP';
            } else if (response.includes('SMTP')) {
                protocol = 'SMTP';
            } else if (response.includes('POP3')) {
                protocol = 'POP3';
            } else if (response.includes('IMAP')) {
                protocol = 'IMAP';
            } else if (response.includes('SMB')) {
                protocol = 'SMB';
            }

            resolve({ port, protocol });
            client.destroy();
        });

        client.on('error', async () => {
            // Attempt TLS connection to check for SSL/TLS services
            try {
                await checkTLS(target, port);
                protocol = 'TLS/SSL';
            } catch (error) {
                // Protocol remains 'Unknown'
            }
            resolve({ port, protocol });
            client.destroy();
        });

        client.on('timeout', () => {
            resolve({ port, protocol: 'Unknown' });
            client.destroy();
        });
    });
}

function checkTLS(target, port) {
    return new Promise((resolve, reject) => {
        const socket = tls.connect(port, target, { timeout: 5000 }, () => {
            if (socket.authorized || socket.authorizationError) {
                resolve(true);
            } else {
                reject(false);
            }
            socket.end();
        });

        socket.on('error', reject);
        socket.on('timeout', () => {
            reject(false);
            socket.end();
        });
    });
}

async function scanTarget(target, portRange) {
    const [startPort, endPort] = portRange.split('-').map(Number);
    const openPorts = [];

    for (let port = startPort; port <= endPort; port++) {
        try {
            const isOpen = await checkPort(target, port);
            if (isOpen) {
                const protocol = await identifyProtocol(target, port);
                openPorts.push(protocol);
            }
        } catch (error) {
            console.error(`Error checking port ${port}:`, error);
        }
    }

    return openPorts;
}

async function checkPort(target, port) {
    return new Promise((resolve, reject) => {
        const client = new net.Socket();

        client.setTimeout(5000);
        client.connect(port, target, () => {
            resolve(true);
            client.destroy();
        });

        client.on('error', () => {
            resolve(false);
        });

        client.on('timeout', () => {
            resolve(false);
            client.destroy();
        });
    });
}

module.exports = scanTarget;
