export type EventType = "start" | "stop" | "error" | "scrape" | "new";
export interface ScrapeOptions {
    /**
     * The interval time in milliseconds between scrapes.
     * @default 10000
     * @minimum 1000
     */
    intervalTime?: number;
    /**
     * Whether to start scraping immediately.
     * @default false
     */
    autoStart?: boolean;
    /**
     * The maximum number of pastes to scrape per interval.
     * @default 50
     * @minimum 1
     * @maximum 250
     */
    limit?: number;
    /**
     * Whether to stop scraping when an error occurs.
     * @default true
     */
    breakOnError?: boolean;
}
/**
 * The scraped paste.
 *
 * @property date {Date} The date the paste was created.
 * @property key {string} The key of the paste.
 * @property size {number} The size of the paste.
 * @property expire {Date | null} The date the paste will expire, or null if it won't.
 * @property title {string} The title of the paste.
 * @property syntax {string} The syntax of the paste.
 * @property user {string} The user who created the paste.
 * @property hits {number} The number of hits the paste has.
 */
export interface ScrapePaste {
    date: Date;
    key: string;
    size: number;
    expire: Date | null;
    title: string;
    syntax: string;
    user: string;
    hits: number;
}
export declare class Scraper {
    #private;
    lastKeys: string[];
    static version: string;
    /**
     * @param opts {ScrapeOptions} The options for the scraper.
     * @throws {Error} If the interval time is not an integer or is less than 1000.
     * @throws {Error} If the limit is not an integer between 1 and 250.
     * @example
     * ```ts
     * const scraper = new Scraper({
     *    intervalTime: 5000,
     *    limit: 10,
     * });
     * ```
     */
    constructor(opts?: ScrapeOptions, fetch?: typeof globalThis.fetch);
    /**
     * Starts the scraper.
     */
    start(): void;
    /**
     * Stops the scraper.
     */
    stop(): void;
    /**
     * Scrapes pastes.
     * @param limit {number} The maximum number of pastes to scrape.
     * @returns {Promise<ScrapePaste[]>} The scraped pastes.
     * @throws {Error} If the limit is not an integer between 1 and 250.
     * @example
     * ```ts
     * const pastes = await scraper.scrape(10);
     * ```
     */
    singleScrape(limit?: number): Promise<ScrapePaste[]>;
    /**
     * Scrapes the last paste.
     *
     * @returns {Promise<ScrapePaste>} The last scraped paste.
     */
    getLast(): Promise<ScrapePaste>;
    /**
     * Gets the raw paste.
     *
     * @param key {string} The key of the paste to fetch.
     * @returns {Promise<string>} The raw paste.
     */
    getRaw(key: string): Promise<string>;
    /**
     * Gets the paste meta.
     *
     * @param key {string} The key of the paste to fetch.
     * @returns {Promise<ScrapePaste>} The paste meta.
     */
    getMeta(key: string): Promise<ScrapePaste>;
    /**
     * Adds an event listener.
     * @param eventName {EventType} The name of the event to listen for.
     * @param handler {Function} The function to call when the event is fired.
     * @example
     * ```ts
     * scraper.on("scrape", (data) => {
     *   console.table(data);
     * });
     * ```
     */
    on(eventName: "start", handler: () => void): void;
    on(eventName: "stop", handler: () => void): void;
    on(eventName: "error", handler: (error: Error) => void): void;
    on(eventName: "scrape", handler: (data: ScrapePaste[]) => void): void;
    on(eventName: "new", handler: (data: ScrapePaste) => void): void;
    get fetch(): typeof globalThis.fetch;
}
