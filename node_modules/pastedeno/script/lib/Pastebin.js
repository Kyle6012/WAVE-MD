"use strict";
// Copyright 2023 J.W. Lagendijk. All rights reserved. MIT license.
var _AbstractPastebin_instances, _a, _AbstractPastebin_config, _AbstractPastebin_fetch, _AbstractPastebin_parseXML, _AbstractPastebin_debug, _AbstractPastebin_postAndParse, _AbstractPastebin_createParams, _AbstractPastebin_validateConfig, _AbstractPastebin_createAPIuserKey, _AbstractPastebin_parseUser, _AbstractPastebin_parsePastes, _AbstractPastebin_getRequestOptions, _AbstractPastebin_handleResponse, _AbstractPastebin_abstractRequest, _AbstractPastebin_getRequest, _AbstractPastebin_postRequest, _AbstractPastebin_debugger;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractPastebin = void 0;
const tslib_1 = require("tslib");
const interfaces_js_1 = require("./interfaces.js");
const isNull = (value) => value === null;
const isUndefined = (value) => typeof value === "undefined";
const ENDPOINTS = {
    POST: "https://pastebin.com/api/api_post.php",
    LOGIN: "https://pastebin.com/api/api_login.php",
    APIRAW: "https://pastebin.com/api/api_raw.php",
    RAW: "https://pastebin.com/raw.php?i=",
};
// @deno-fmt-ignore
const formatTypeArr = [
    "4cs", "6502acme", "6502kickass", "6502tasm", "abap", "actionscript", "actionscript3", "ada", "aimms", "algol68", "apache", "applescript", "apt_sources", "arduino", "arm", "asm", "asp", "asymptote", "autoconf", "autohotkey", "autoit", "avisynth", "awk", "bascomavr", "bash", "basic4gl", "dos", "bibtex", "b3d", "blitzbasic", "bmx", "bnf", "boo", "bf", "c", "csharp", "c_winapi", "cpp", "cpp-winapi", "cpp-qt", "c_loadrunner", "caddcl", "cadlisp", "ceylon", "cfdg", "c_mac", "chaiscript", "chapel", "cil", "clojure", "klonec", "klonecpp", "cmake", "cobol", "coffeescript", "cfm", "css", "cuesheet", "d", "dart", "dcl", "dcpu16", "dcs", "delphi", "oxygene", "diff", "div", "dot", "e", "ezt", "ecmascript", "eiffel", "email", "epc", "erlang", "euphoria", "fsharp", "falcon", "filemaker", "fo", "f1", "fortran", "freebasic", "freeswitch", "gambas", "gml", "gdb", "gdscript", "genero", "genie", "gettext", "go", "godot-glsl", "groovy", "gwbasic", "haskell", "haxe", "hicest", "hq9plus", "html4strict", "html5", "icon", "idl", "ini", "inno", "intercal", "io", "ispfpanel", "j", "java", "java5", "javascript", "jcl", "jquery", "json", "julia", "kixtart", "kotlin", "ksp", "latex", "ldif", "lb", "lsl2", "lisp", "llvm", "locobasic", "logtalk", "lolcode", "lotusformulas", "lotusscript", "lscript", "lua", "m68k", "magiksf", "make", "mapbasic", "markdown", "matlab", "mercury", "metapost", "mirc", "mmix", "mk-61", "modula2", "modula3", "68000devpac", "mpasm", "mxml", "mysql", "nagios", "netrexx", "newlisp", "nginx", "nim", "nsis", "oberon2", "objeck", "objc", "ocaml", "ocaml-brief", "octave", "pf", "glsl", "oorexx", "oobas", "oracle8", "oracle11", "oz", "parasail", "parigp", "pascal", "pawn", "pcre", "per", "perl", "perl6", "phix", "php", "php-brief", "pic16", "pike", "pixelbender", "pli", "plsql", "postgresql", "postscript", "povray", "powerbuilder", "powershell", "proftpd", "progress", "prolog", "properties", "providex", "puppet", "purebasic", "pycon", "python", "pys60", "q", "qbasic", "qml", "rsplus", "racket", "rails", "rbs", "rebol", "reg", "rexx", "robots", "roff", "rpmspec", "ruby", "gnuplot", "rust", "sas", "scala", "scheme", "scilab", "scl", "sdlbasic", "smalltalk", "smarty", "spark", "sparql", "sqf", "sql", "sshconfig", "standardml", "stonescript", "sclang", "swift", "systemverilog", "tsql", "tcl", "teraterm", "texgraph", "thinbasic", "typescript", "typoscript", "unicon", "uscript", "upc", "urbi", "vala", "vbnet", "vbscript", "vedit", "verilog", "vhdl", "vim", "vb", "visualfoxpro", "visualprolog", "whitespace", "whois", "winbatch", "xbasic", "xml", "xojo", "xorg_conf", "xpp", "yaml", "yara", "z80", "zxbasic"
];
const expirationTimeArr = Object.values(interfaces_js_1.ExpirationTime);
class AbstractPastebin {
    constructor(config, options) {
        _AbstractPastebin_instances.add(this);
        _AbstractPastebin_config.set(this, void 0);
        // We're able to overwrite fetch because it is an abstract class
        _AbstractPastebin_fetch.set(this, globalThis.fetch);
        _AbstractPastebin_parseXML.set(this, void 0);
        // RequestTimeout = 4000;
        Object.defineProperty(this, "requestTimeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 4000
        });
        // DEBUG
        _AbstractPastebin_debug.set(this, false);
        if (options?.fetch) {
            tslib_1.__classPrivateFieldSet(this, _AbstractPastebin_fetch, options.fetch, "f");
        }
        if (options?.parseXML) {
            tslib_1.__classPrivateFieldSet(this, _AbstractPastebin_parseXML, options.parseXML, "f");
        }
        else {
            tslib_1.__classPrivateFieldSet(this, _AbstractPastebin_parseXML, (_xml) => {
                throw new Error("Not implemented!");
            }, "f");
        }
        if (isUndefined(config) || isNull(config)) {
            tslib_1.__classPrivateFieldSet(this, _AbstractPastebin_config, {}, "f");
            return;
        }
        let conf = config;
        if (typeof conf === "string") {
            conf = { api_dev_key: conf };
        }
        tslib_1.__classPrivateFieldSet(this, _AbstractPastebin_debug, conf.debug === true, "f");
        delete conf.debug;
        tslib_1.__classPrivateFieldSet(this, _AbstractPastebin_config, Object.assign({
            api_dev_key: null,
            api_user_key: null,
            api_user_name: null,
            api_user_password: null,
        }, conf), "f");
    }
    setDebug(debug) {
        tslib_1.__classPrivateFieldSet(this, _AbstractPastebin_debug, debug, "f");
    }
    /**
     * Get the content of a paste
     *
     * @param id ID of the paste
     * @param isPrivate is the paste private? Needs authentication
     * @returns { Promise<string> } returns the content of the paste
     */
    async getPaste(id, isPrivate = false) {
        let ID = id;
        if (ID.startsWith("https://pastebin.com/")) {
            ID = ID.replace("https://pastebin.com/", "");
        }
        if (!ID || ID.length === 0) {
            return Promise.reject(new Error("Invalid paste url or id"));
        }
        if (isPrivate) {
            const params = tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_createParams).call(this, "show_paste");
            params.api_paste_key = ID;
            try {
                await tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_createAPIuserKey).call(this);
                params.api_user_key = this.config.api_user_key;
                return tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_postRequest).call(this, ENDPOINTS.APIRAW, params);
            }
            catch (error) {
                return Promise.reject(error);
            }
        }
        return tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_getRequest).call(this, ENDPOINTS.RAW + ID);
    }
    /**
     * Create a paste
     *
     * @param options { ICreatePasteTextOptions } options for creating a paste
     * @returns { Promise<string> } returns the url of the created paste
     */
    async createPaste(options) {
        if (!this.hasDevKey) {
            return Promise.reject(new Error("Dev key needed!"));
        }
        if (typeof options === "undefined") {
            return Promise.reject(new Error("Create paste needs options!"));
        }
        const { text, title, format, expiration } = options;
        let { privacy } = options;
        if (isUndefined(privacy) || typeof privacy !== "number") {
            privacy = interfaces_js_1.PrivacyLevel.PUBLIC_ANONYMOUS;
        }
        else if (privacy > 3 || privacy < 0) {
            return Promise.reject(new Error("Privacy level can only be 0 - 3"));
        }
        const params = tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_createParams).call(this, "paste");
        params.api_paste_code = text;
        params.api_paste_private = privacy;
        if (typeof text !== "string") {
            return Promise.reject(new Error("text can only be of type string!"));
        }
        if (!text || text.length === 0) {
            return Promise.reject(new Error("Paste cannot have empty content"));
        }
        if (typeof title === "string") {
            params.api_paste_name = title;
        }
        if (typeof format === "string") {
            if (formatTypeArr.includes(format)) {
                params.api_paste_format = format;
            }
            else {
                return Promise.reject(new Error(`Paste format ${options.format} is unknown!`));
            }
        }
        if (privacy === interfaces_js_1.PrivacyLevel.PRIVATE ||
            privacy === interfaces_js_1.PrivacyLevel.PUBLIC_USER) {
            try {
                await tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_createAPIuserKey).call(this);
            }
            catch (error) {
                return Promise.reject(error);
            }
            params.api_user_key = this.config.api_user_key;
        }
        if (typeof expiration === "string") {
            if (expirationTimeArr.includes(expiration)) {
                params.api_paste_expire_date = expiration;
            }
            else {
                return Promise.reject(new Error(`Expiration format '${expiration}' is unknown!`));
            }
        }
        params.api_paste_private = privacy === interfaces_js_1.PrivacyLevel.PUBLIC_USER
            ? interfaces_js_1.PrivacyLevel.PUBLIC_ANONYMOUS
            : privacy;
        return tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_postRequest).call(this, ENDPOINTS.POST, params);
    }
    /**
     * Delete a paste
     *
     * @param pasteID { string } ID of the paste
     * @returns { Promise<string> } returns the response of the request
     */
    async deletePaste(pasteID) {
        if (!this.hasDevKey) {
            return Promise.reject(new Error("Dev key needed!"));
        }
        let ID = pasteID;
        if (ID.startsWith("https://pastebin.com/")) {
            ID = ID.replace("https://pastebin.com/", "");
        }
        const params = tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_createParams).call(this, "delete");
        params.api_paste_key = ID;
        try {
            await tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_createAPIuserKey).call(this);
        }
        catch (error) {
            return Promise.reject(error);
        }
        params.api_user_key = this.config.api_user_key;
        return tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_postRequest).call(this, ENDPOINTS.POST, params);
    }
    /**
     * List all pastes of a user
     *
     * @param limit { number } limit of pastes to return (default: 50, max: 1000)
     * @returns { Promise<Paste[]> } returns an array of pastes
     * @throws { Error } throws an error if the limit is not between 1 and 1000
     * @throws { Error } throws an error if the dev key is missing
     */
    async listUserPastes(limit = 50) {
        if (limit < 1 || limit > 1000) {
            return Promise.reject(new Error("listUserPastes only accepts a limit between 1 and 1000"));
        }
        if (!this.hasDevKey) {
            return Promise.reject(new Error("Dev key needed!"));
        }
        const params = tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_createParams).call(this, "list");
        params.api_results_limit = limit;
        try {
            await tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_createAPIuserKey).call(this);
        }
        catch (error) {
            return Promise.reject(error);
        }
        params.api_user_key = this.config.api_user_key;
        return tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_postAndParse).call(this, params, tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_parsePastes));
    }
    /**
     * Get user information
     *
     * @returns { Promise<User> } returns the user information
     * @throws { Error } throws an error if the dev key is missing
     */
    async getUserInfo() {
        if (!this.hasDevKey) {
            return Promise.reject(new Error("Dev key needed!"));
        }
        const params = tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_createParams).call(this, "userdetails");
        try {
            await tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_createAPIuserKey).call(this);
        }
        catch (error) {
            return Promise.reject(error);
        }
        params.api_user_key = this.config.api_user_key;
        return tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_postAndParse).call(this, params, tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_parseUser));
    }
    // Getters
    get debug() {
        return tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_debug, "f");
    }
    get config() {
        return tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_config, "f");
    }
    get hasDevKey() {
        return tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_validateConfig).call(this, "api_dev_key") === false;
    }
}
exports.AbstractPastebin = AbstractPastebin;
_a = AbstractPastebin, _AbstractPastebin_config = new WeakMap(), _AbstractPastebin_fetch = new WeakMap(), _AbstractPastebin_parseXML = new WeakMap(), _AbstractPastebin_debug = new WeakMap(), _AbstractPastebin_instances = new WeakSet(), _AbstractPastebin_postAndParse = function _AbstractPastebin_postAndParse(params, parseFunc) {
    return tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_postRequest).call(this, ENDPOINTS.POST, params)
        .then((data) => {
        return parseFunc.call(this, data);
    });
}, _AbstractPastebin_createParams = function _AbstractPastebin_createParams(option) {
    const opts = {
        api_option: option,
    };
    if (this.config.api_dev_key) {
        opts.api_dev_key = this.config.api_dev_key;
    }
    return opts;
}, _AbstractPastebin_validateConfig = function _AbstractPastebin_validateConfig(...validateKeys) {
    const missing = validateKeys.filter((key) => isUndefined(tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_config, "f")[key]) ||
        tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_config, "f")[key] === null ||
        tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_config, "f")[key] === "");
    if (missing.length > 0) {
        return `The following keys are missing: ${missing.join(",")}`;
    }
    return false;
}, _AbstractPastebin_createAPIuserKey = function _AbstractPastebin_createAPIuserKey() {
    const inValid = tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_validateConfig).call(this, "api_dev_key", "api_user_name", "api_user_password");
    if (typeof inValid === "string") {
        return Promise.reject(new Error(inValid));
    }
    if (!isUndefined(this.config.api_user_key) &&
        !isNull(this.config.api_user_key) &&
        this.config.api_user_key !== "") {
        // We already have a key. Returning
        return Promise.resolve();
    }
    const { api_dev_key, api_user_name, api_user_password } = this.config;
    return tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_postRequest).call(this, ENDPOINTS.LOGIN, {
        api_dev_key,
        api_user_name,
        api_user_password,
    }).then((data) => {
        if (data.length !== 32) {
            return Promise.reject(new Error(`Error in creating user key: ${data}`));
        }
        this.config.api_user_key = data;
        return Promise.resolve();
    });
}, _AbstractPastebin_parseUser = function _AbstractPastebin_parseUser(xml) {
    const data = tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_parseXML, "f").call(this, xml);
    if (isUndefined(data) || isNull(data) || isUndefined(data.user)) {
        throw new Error("No data returned to _parseUser!");
    }
    return data.user;
}, _AbstractPastebin_parsePastes = function _AbstractPastebin_parsePastes(xml) {
    const { root: data } = tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_parseXML, "f").call(this, `<root>${xml}</root>`);
    if (isUndefined(data) || isNull(data) || isUndefined(data.paste)) {
        throw new Error("No data returned to _parsePastes!");
    }
    return data.paste;
}, _AbstractPastebin_getRequestOptions = function _AbstractPastebin_getRequestOptions(method, params = {}) {
    const init = {
        headers: new Headers({
            "User-Agent": `Pastedeno/v${_a.version}`,
            "Cache-Control": "no-cache",
        }),
        method,
        cache: "no-cache",
    };
    if (method === "POST") {
        // form
        const formData = new FormData();
        for (const [key, value] of Object.entries(params)) {
            formData.append(key, value);
        }
        init.body = formData;
    }
    return init;
}, _AbstractPastebin_handleResponse = async function _AbstractPastebin_handleResponse(res) {
    if (res.status === 404) {
        return Promise.reject(new Error("Not found!"));
    }
    if (res.status === 403) {
        return Promise.reject(new Error("Forbidden! Is this paste private?"));
    }
    if (!res.ok) {
        return Promise.reject(new Error(`Response not ok: ${res.status} : ${res.statusText}`));
    }
    let buffer;
    try {
        buffer = await res.arrayBuffer();
    }
    catch (error) {
        return Promise.reject(error);
    }
    // parse Buffer as text
    const text = new TextDecoder().decode(buffer);
    if (text.includes("Bad API request")) {
        return Promise.reject(new Error("Bad API request"));
    }
    if (text.includes("Post limit")) {
        return Promise.reject(new Error("Post limit reached"));
    }
    return text;
}, _AbstractPastebin_abstractRequest = async function _AbstractPastebin_abstractRequest(method, path, params) {
    const init = tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_getRequestOptions).call(this, method, params);
    let timeout = null;
    if (this.requestTimeout > 0 && AbortController) {
        const abortController = new AbortController();
        init.signal = abortController.signal;
        timeout = setTimeout(() => {
            tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_debugger).call(this, ">>>>> aborting request");
            if (abortController) {
                abortController.abort();
            }
            timeout = null;
        }, this.requestTimeout);
    }
    try {
        const res = await tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_fetch, "f").call(this, path, init);
        if (timeout !== null) {
            clearTimeout(timeout);
        }
        return tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_handleResponse).call(this, res);
    }
    catch (error) {
        return Promise.reject(error);
    }
}, _AbstractPastebin_getRequest = function _AbstractPastebin_getRequest(path) {
    tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_debugger).call(this, ">>>>> getRequest", path);
    return tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_abstractRequest).call(this, "GET", path);
}, _AbstractPastebin_postRequest = function _AbstractPastebin_postRequest(path, params) {
    tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_debugger).call(this, ">>>>> postRequest", path, params);
    return tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_instances, "m", _AbstractPastebin_abstractRequest).call(this, "POST", path, params);
}, _AbstractPastebin_debugger = function _AbstractPastebin_debugger(...args) {
    if (tslib_1.__classPrivateFieldGet(this, _AbstractPastebin_debug, "f")) {
        console.log(...args);
    }
};
// VERSION
Object.defineProperty(AbstractPastebin, "version", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "0.6.1"
});
