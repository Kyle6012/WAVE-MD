"use strict";
// Copyright 2023 J.W. Lagendijk. All rights reserved. MIT license.
var _Scraper_instances, _Scraper_fetch, _Scraper_events, _Scraper_limit, _Scraper_breakOnError, _Scraper_intervalLength, _Scraper_timeout, _Scraper_scrapeAndFire, _Scraper_scrape, _Scraper_fire;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scraper = void 0;
const tslib_1 = require("tslib");
const evt_1 = require("evt");
const ENDPOINTS = {
    SCRAPE: "https://scrape.pastebin.com/api_scraping.php",
    RAW: "https://scrape.pastebin.com/api_scrape_item.php?i=",
    META: "https://scrape.pastebin.com/api_scrape_item_meta.php?i=",
};
const defaultOptions = {
    intervalTime: 10000,
    autoStart: false,
    limit: 50,
    breakOnError: true,
};
const convertData = (paste) => {
    const date = new Date(parseInt(paste.date, 10) * 1000);
    const expireNum = parseInt(paste.expire, 10);
    const expire = expireNum === 0 ? null : new Date(expireNum * 1000);
    const size = parseInt(paste.size, 10);
    const hits = parseInt(paste.hits, 10);
    return {
        key: paste.key,
        title: paste.title,
        syntax: paste.syntax,
        user: paste.user,
        date,
        expire,
        size,
        hits,
    };
};
class Scraper {
    /**
     * @param opts {ScrapeOptions} The options for the scraper.
     * @throws {Error} If the interval time is not an integer or is less than 1000.
     * @throws {Error} If the limit is not an integer between 1 and 250.
     * @example
     * ```ts
     * const scraper = new Scraper({
     *    intervalTime: 5000,
     *    limit: 10,
     * });
     * ```
     */
    constructor(opts, fetch) {
        _Scraper_instances.add(this);
        // We're able to overwrite fetch because it is an abstract class
        _Scraper_fetch.set(this, globalThis.fetch);
        _Scraper_events.set(this, new evt_1.Evt());
        _Scraper_limit.set(this, 50);
        _Scraper_breakOnError.set(this, false);
        _Scraper_intervalLength.set(this, void 0);
        _Scraper_timeout.set(this, null);
        Object.defineProperty(this, "lastKeys", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        _Scraper_scrapeAndFire.set(this, async (withTimeout = false) => {
            let errored = false;
            try {
                const data = await tslib_1.__classPrivateFieldGet(this, _Scraper_scrape, "f").call(this);
                tslib_1.__classPrivateFieldGet(this, _Scraper_instances, "m", _Scraper_fire).call(this, "scrape", data);
            }
            catch (error) {
                errored = true;
                tslib_1.__classPrivateFieldGet(this, _Scraper_instances, "m", _Scraper_fire).call(this, "error", error);
            }
            if (withTimeout) {
                if (errored && tslib_1.__classPrivateFieldGet(this, _Scraper_breakOnError, "f")) {
                    this.stop();
                }
                else {
                    tslib_1.__classPrivateFieldSet(this, _Scraper_timeout, setTimeout(() => tslib_1.__classPrivateFieldGet(this, _Scraper_scrapeAndFire, "f").call(this, true), tslib_1.__classPrivateFieldGet(this, _Scraper_intervalLength, "f")), "f");
                }
            }
        });
        _Scraper_scrape.set(this, async (limit) => {
            if (typeof limit !== "undefined") {
                if (Number.isNaN(limit) || !Number.isInteger(limit) || limit < 1 || limit > 250) {
                    throw new Error("Limit must be an integer between 1 and 250!");
                }
            }
            const limited = typeof limit !== "undefined" ? limit : tslib_1.__classPrivateFieldGet(this, _Scraper_limit, "f");
            const response = await tslib_1.__classPrivateFieldGet(this, _Scraper_fetch, "f").call(this, `${ENDPOINTS.SCRAPE}?limit=${limited}`);
            if (response.status === 403) {
                const text = await response.text();
                throw new Error(`Pastebin blocked you, have you whitelisted your IP? \n\n Response: ${text}`);
            }
            if (!response.ok) {
                throw new Error(`Error scraping: ${response.statusText}`);
            }
            const raw = await response.json();
            const data = raw.map(convertData);
            const newPastes = data.filter((paste) => !this.lastKeys.includes(paste.key));
            if (newPastes.length > 0) {
                // emit newPastes (reversed, so oldest first)
                newPastes.reverse().forEach((paste) => tslib_1.__classPrivateFieldGet(this, _Scraper_instances, "m", _Scraper_fire).call(this, "new", paste));
            }
            this.lastKeys = data.map((paste) => paste.key);
            return data;
        });
        const options = {
            ...defaultOptions,
            ...opts,
        };
        if (fetch) {
            tslib_1.__classPrivateFieldSet(this, _Scraper_fetch, fetch, "f");
        }
        if (typeof options.intervalTime === "undefined" || !Number.isInteger(options.intervalTime) ||
            options.intervalTime < 1000) {
            throw new Error("Interval time must be an integer and at least 1000!");
        }
        tslib_1.__classPrivateFieldSet(this, _Scraper_intervalLength, options.intervalTime, "f");
        if (typeof options.limit !== "undefined" && (Number.isNaN(options.limit) ||
            !Number.isInteger(options.limit) ||
            options.limit < 1 ||
            options.limit > 250)) {
            throw new Error("Limit must be an integer between 1 and 250!");
        }
        else if (typeof options.limit !== "undefined") {
            tslib_1.__classPrivateFieldSet(this, _Scraper_limit, options.limit, "f");
        }
        if (typeof options.breakOnError !== "undefined") {
            tslib_1.__classPrivateFieldSet(this, _Scraper_breakOnError, options.breakOnError, "f");
        }
        if (options.autoStart) {
            this.start();
        }
    }
    /**
     * Starts the scraper.
     */
    start() {
        if (tslib_1.__classPrivateFieldGet(this, _Scraper_timeout, "f") === null) {
            tslib_1.__classPrivateFieldGet(this, _Scraper_instances, "m", _Scraper_fire).call(this, "start");
            tslib_1.__classPrivateFieldGet(this, _Scraper_scrapeAndFire, "f").call(this, true);
        }
    }
    /**
     * Stops the scraper.
     */
    stop() {
        tslib_1.__classPrivateFieldGet(this, _Scraper_instances, "m", _Scraper_fire).call(this, "stop");
        if (tslib_1.__classPrivateFieldGet(this, _Scraper_timeout, "f") !== null) {
            clearTimeout(tslib_1.__classPrivateFieldGet(this, _Scraper_timeout, "f"));
            tslib_1.__classPrivateFieldSet(this, _Scraper_timeout, null, "f");
        }
    }
    /**
     * Scrapes pastes.
     * @param limit {number} The maximum number of pastes to scrape.
     * @returns {Promise<ScrapePaste[]>} The scraped pastes.
     * @throws {Error} If the limit is not an integer between 1 and 250.
     * @example
     * ```ts
     * const pastes = await scraper.scrape(10);
     * ```
     */
    singleScrape(limit) {
        return tslib_1.__classPrivateFieldGet(this, _Scraper_scrape, "f").call(this, limit);
    }
    /**
     * Scrapes the last paste.
     *
     * @returns {Promise<ScrapePaste>} The last scraped paste.
     */
    getLast() {
        return tslib_1.__classPrivateFieldGet(this, _Scraper_scrape, "f").call(this, 1).then((data) => data[0]);
    }
    /**
     * Gets the raw paste.
     *
     * @param key {string} The key of the paste to fetch.
     * @returns {Promise<string>} The raw paste.
     */
    getRaw(key) {
        const realKey = key
            .replace("https://scrape.pastebin.com/api_scrape_item.php?i=", "")
            .replace("https://pastebin.com/", "");
        return tslib_1.__classPrivateFieldGet(this, _Scraper_fetch, "f").call(this, `${ENDPOINTS.RAW}${realKey}`)
            .then((response) => {
            if (!response.ok) {
                throw new Error(`Error fetching raw: ${response.statusText}`);
            }
            return response.text();
        });
    }
    /**
     * Gets the paste meta.
     *
     * @param key {string} The key of the paste to fetch.
     * @returns {Promise<ScrapePaste>} The paste meta.
     */
    getMeta(key) {
        const realKey = key
            .replace("https://scrape.pastebin.com/api_scrape_item.php?i=", "")
            .replace("https://pastebin.com/", "");
        return tslib_1.__classPrivateFieldGet(this, _Scraper_fetch, "f").call(this, `${ENDPOINTS.META}${realKey}`)
            .then((response) => {
            if (!response.ok) {
                throw new Error(`Error fetching meta: ${response.statusText}`);
            }
            return response.json();
        })
            .then((data) => convertData(data));
    }
    on(eventName, handler) {
        tslib_1.__classPrivateFieldGet(this, _Scraper_events, "f").$attach((0, evt_1.to)(eventName), handler);
    }
    get fetch() {
        return tslib_1.__classPrivateFieldGet(this, _Scraper_fetch, "f");
    }
}
exports.Scraper = Scraper;
_Scraper_fetch = new WeakMap(), _Scraper_events = new WeakMap(), _Scraper_limit = new WeakMap(), _Scraper_breakOnError = new WeakMap(), _Scraper_intervalLength = new WeakMap(), _Scraper_timeout = new WeakMap(), _Scraper_scrapeAndFire = new WeakMap(), _Scraper_scrape = new WeakMap(), _Scraper_instances = new WeakSet(), _Scraper_fire = function _Scraper_fire(eventName, ...args) {
    const callArgs = [
        eventName,
        ...args,
    ];
    tslib_1.__classPrivateFieldGet(this, _Scraper_events, "f").post.call(tslib_1.__classPrivateFieldGet(this, _Scraper_events, "f"), callArgs);
};
// Version
Object.defineProperty(Scraper, "version", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "0.6.1"
});
